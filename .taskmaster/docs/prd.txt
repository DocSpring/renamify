Refaktor v1.0.0 - Product Requirements Document (PRD)
Owner: Nathan Broadbent
Date: 2025-08-11
Repo files referenced: INITIAL_PLANNING.md, CLAUDE.md, .taskmaster/templates/example_prd.txt

1) Summary
- Refaktor is a cross-case-aware refactoring tool that performs content replacement and filesystem renames in one atomic operation with full undo and redo.
- It ships as three deliverables that share one core: a Rust core library and CLI, a VS Code extension, and an MCP server wrapper that talks to the CLI.
- Core technologies: ripgrep crates for fast search, git for safety and rollback, JSON for change plans and history.
- Project status: greenfield, unreleased. No backwards compatibility guarantees. Old code is deleted aggressively.

2) Problem
Developers routinely need to rename concepts across code and filenames, but existing tools are fragmented:
- Editors can replace text but do not understand multiple case styles at once.
- File renamers can change casing but do not touch code.
- There is no safe, atomic, cross-case, repo-wide refactor with preview, apply, and undo.
Consequence: brittle search and replace scripts, missed variants, and partial renames that require manual cleanup.

3) Goals
- Case intelligence: detect a source token and generate all target variants across common naming conventions.
- One-pass search: compile all variants into a single regex and run a single fast scan.
- Unified apply: update file contents and rename files and directories in one atomic transaction.
- Safety: preview plan, detect conflicts, and allow instant rollback. History independent of git commit history.
- Ergonomics: simple CLI, tight VS Code UX, MCP tools for AI agents.
- Cross platform: macOS, Linux, Windows. Case-insensitive filesystems supported safely.

Non-goals for v1.0.0
- No AST-based or language-semantic refactoring.
- No IDEs other than VS Code.
- No remote execution. Local only.
- No telemetry by default.

4) Target users and top use cases
- Any developer working in mixed-language repos.
- Killer demos:
  - Rename a React component across TSX, CSS Modules, and file and directory names.
  - Refactor a Ruby model from PascalCase to a new name and update snake_case filenames and references.

5) Scope and requirements

5.1 Functional requirements
- Cross-case variant generation
  - Supported styles: snake_case, kebab-case, camelCase, PascalCase, SCREAMING_SNAKE_CASE, Title Case, Train-Case, dot.case.
  - Input: source token and target token in any style. Output: mapping table old_variant -> new_variant for all styles.
- Search and plan
  - Detect dominant style of the source token, generate a union of all variant regexes, and scan the repo once.
  - Respect .gitignore and user include and exclude globs.
  - Exclude binary files by default. Configurable include.
  - Produce a plan.json with match hunks, before and after previews, and a summary diff.
- Apply and rollback
  - Apply edits and renames atomically.
  - If any step fails, rollback everything. No partial renames.
  - Store applied plans in history.json with unique ids.
  - Undo and redo operate by id and restore the exact prior state.
- File and directory rename rules
  - Rename files and directories whose names contain any old_variant to the corresponding new_variant.
  - Depth-sorted ordering to avoid rename conflicts. Detect and avoid collisions.
- Conflict detection
  - Re-validate hunks at apply time. If surrounding context has changed or count of occurrences differs, mark conflict.
  - Auto-resolve if the replacement still exists in-line post-formatting change. Otherwise require manual review or exclude.
  - Git-backed safety: use git to snapshot and apply patches to improve resilience.
- Preview UX
  - Show counts by variant, by file, and grouped by content vs rename.
  - Provide unified diff output and a compact table view.
- History
  - history.json in .refaktor/ with plan metadata, affected files, and content hashes for verification.

5.2 CLI requirements
- Binary name: refaktor
- Commands:
  - refaktor plan <old> <new> [options]
    - --include, --exclude, --respect-gitignore (default true)
    - --rename-files, --rename-dirs (both default true)
    - --styles=<comma list> to restrict styles
    - --preview-format table|diff|json (default table)
    - --plan-out path (default .refaktor/plan.json)
  - refaktor apply [--plan path or --id <history id>] [--atomic true] [--commit]
    - --commit optionally creates a git commit with a generated message
  - refaktor undo <id>
  - refaktor redo <id>
  - refaktor status
  - refaktor history [--limit N]
  - refaktor dry-run alias for plan with preview only
- Exit codes: 0 success, 1 conflicts, 2 invalid input, 3 internal error.
- Performance target: scan 100k files and generate plan within seconds on an SSD-backed repo, comparable to ripgrep speed.

5.3 VS Code extension requirements
- Commands:
  - Refaktor: Plan Rename
  - Refaktor: Preview Plan
  - Refaktor: Apply Plan
  - Refaktor: Undo Last Refaktor
- UI:
  - QuickPick to select old and new names, style filters, include and exclude globs.
  - Diff-style preview webview with files, hunks, and rename badges.
  - Non-blocking progress with cancel that kills the CLI process.
- Implementation:
  - TypeScript extension that shells out to the refaktor CLI with a JSON protocol over stdio.
  - Bundled platform binaries or download-on-demand. Configurable path.

5.4 MCP server requirements
- Node TypeScript service that wraps the CLI and exposes tools:
  - plan, apply, undo, history, preview
- Installed via npx and expects refaktor CLI to be installed on PATH.
- Returns structured JSON results for Cursor or other MCP clients.

5.5 Data formats
- .refaktor/plan.json
  - { id, created_at, old, new, styles[], includes[], excludes[], matches[], renames[], stats, version }
- .refaktor/history.json
  - Append-only list of applied plans with checksums and revert info.

5.6 Quality and testing
- 100 percent test coverage for the Rust core and CLI core operations. CI fails below threshold.
- Property tests for case conversions and regex boundary detection.
- Snapshot tests for plan.json and diff output.
- Integration tests for atomic rename behavior, rollback, and cross-platform path handling.
- Fuzz tests for regex generation to avoid catastrophic backtracking.

5.7 Security and safety
- Does not run user code. Only reads and writes files under the working directory.
- Never modifies .git directory internals directly. Use git porcelain commands only when requested.
- Handles symlinks safely and does not traverse outside the repo root.

5.8 Compatibility and packaging
- Platforms: macOS x64 and arm64, Linux x64 and arm64, Windows x64.
- Install: Homebrew, cargo install, curl | sh installer, Scoop and winget where feasible.
- Minimum git version specified in docs. ripgrep not required at runtime since we embed its crates.

6) UX flows

Flow A - React component rename
- User runs: refaktor plan UserCard AccountCard --include "src/**"
- Preview shows content changes in .tsx and .css, plus file and directory renames.
- User runs: refaktor apply --commit
- In VS Code, the extension shows a success toast and the git commit appears.

Flow B - Ruby model rename
- User runs: refaktor plan UserProfile CustomerAccount --include "app/**" --include "db/**"
- The plan updates PascalCase classes, snake_case file paths, and related specs.

7) Engineering notes
- Case detection first, then generate all old variants, then map each to corresponding new variants using a uniform token model.
- Build one combined regex with alternation and boundary heuristics. Prefer Rust regex engine to keep performance and avoid lookbehind. Use additional checks in code to enforce boundaries when needed.
- Run one repo scan using embedded grep crates. Collect matches and write plan.json.
- For atomic apply:
  - Create a safe point using git (optional). Otherwise create a temporary working copy backup for edited files and pending renames.
  - Apply content edits first, then perform renames depth-first to avoid conflicts.
  - If any failure, restore backups or use git to reset the working tree to the safe point.
- Conflict rules:
  - If the number of replaceable occurrences on a line has changed and cannot be reconciled, mark as conflict and stop apply unless --force-with-conflicts is set.

8) Success metrics
- Time to plan vs raw ripgrep within 1.5x on large repos.
- Zero partial state after failures. Verified by end-to-end tests.
- 100 percent test coverage for core.
- First month: 100 GitHub stars and 10 active users executing at least one apply in a real repo.
- Marketplace rating 4.7+ after first 10 reviews.

9) Risks and mitigations
- Regex boundaries in camel case without lookbehind can be tricky. Mitigation: post-filter matches and property tests.
- Case-insensitive filesystems can collide on rename. Mitigation: staged renames with temporary names and depth ordering.
- Very large repos may blow memory with full plan. Mitigation: stream matches and write incremental plan chunks.
- Windows path and file locks. Mitigation: retry strategy and clear messaging.

10) Rollout plan
- Alpha: CLI only, manual installs, dogfooding on DocSpring scale repos.
- Beta: VS Code extension with signed builds and MCP server.
- GA: Homebrew and marketplace listings with docs, examples, and a demo video.

11) Documentation
- Update CLAUDE.md with: project is unreleased, no backwards compatibility, delete old code promptly, prioritize developer experience.
- README quickstart with copy and paste commands.
- Examples folder with sample renames and expected outputs.

12) Open questions
- Final license MIT or Apache-2.0.
- Do we require git for all operations or only for commit convenience and rollback.
- Default style list shipped in v1 and which additional styles to add later.
- Should we support rename plans composed from multiple old->new pairs in one transaction.

13) Task list for Task Master

T-001 Bootstrap Rust workspace
- Create refaktor-cli and refaktor-core crates.
- Set up cargo workspace, linting, formatting, and baseline CI.

Acceptance criteria:
- cargo build and cargo test pass on macOS and Linux.
- CI runs formatting, clippy, tests.

T-002 Implement case token model and converters
- Tokenize identifiers and implement conversions across supported styles.
- Property tests for round-trips.

Acceptance criteria:
- Given a pair old and new, generate all variant mappings correctly.
- 100 percent coverage for conversion module.

T-003 Regex generation and boundary rules
- Build alternation regex for all old variants with word and token boundaries.

Acceptance criteria:
- No catastrophic backtracking on fuzz corpus.
- Matches and only matches intended tokens on test corpus.

T-004 Repo scan using embedded grep crates
- Run a single scan collecting matches into plan.json.

Acceptance criteria:
- Respect .gitignore and include and exclude globs.
- Performance within target on test repo.

T-005 Plan preview outputs
- Table and diff previews in terminal.
- JSON plan file format stabilized.

Acceptance criteria:
- Snapshot tests for both formats.

T-006 Atomic apply engine
- Apply content edits and renames with rollback on failure.

Acceptance criteria:
- Depth ordered renames, collision handling, backups.
- End-to-end tests verify no partial state after induced failures.

T-007 Conflict detection
- Re-validate hunks and mark conflicts.

Acceptance criteria:
- Replacements that no longer match do not silently apply.
- Auto-resolve simple formatting-only changes.

T-008 History and undo and redo
- Store applied plans in history.json and implement undo and redo.

Acceptance criteria:
- Undo restores file contents and names exactly.
- Redo re-applies cleanly.

T-009 VS Code extension
- Implement plan, preview, apply, undo commands and UI.

Acceptance criteria:
- Works on macOS and Windows in a sample repo.
- Uses installed CLI via configured path.

T-010 MCP server
- Expose plan, apply, undo, history tools.

Acceptance criteria:
- npx launchable, returns structured JSON, tested with Cursor.

T-011 Packaging
- Homebrew formula and curl installer. Windows scoop where feasible.

Acceptance criteria:
- Fresh machine can install and run refaktor.

T-012 Docs
- README, CONTRIBUTING, CHANGELOG, example scenarios, and the CLAUDE.md note.

Acceptance criteria:
- All command examples copy and paste successfully.

Appendix A - CLI examples

1) Basic plan and apply
refaktor plan UserCard AccountCard --include "src/**" --preview-format table
refaktor apply --commit

2) Restrict styles and dry run
refaktor plan UserProfile CustomerAccount --styles=camel,Pascal,snake --dry-run

3) Rename files and dirs only
refaktor plan User User --rename-files --rename-dirs --styles=snake,kebab --include "assets/**"

4) Undo
refaktor undo <id>

End of PRD
