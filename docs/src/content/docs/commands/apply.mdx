---
title: renamify apply
description: Execute a previously generated renaming plan
---

The `apply` command executes a previously generated plan, making all the planned
changes to your codebase atomically.

## Usage

```bash
renamify apply [ID] [OPTIONS]
```

## Arguments

- `[ID]` - Plan ID, file path, or "latest" (optional - defaults to
  .renamify/plan.json)

## Options

- `--commit` - Create a git commit after applying
- `--force-with-conflicts` - Apply even if conflicts are detected

## How It Works

When you run `apply`, Renamify:

1. **Loads the plan** from the specified file
2. **Validates the plan** and checks for conflicts
3. **Creates backups** of all files to be modified
4. **Applies content changes** to files atomically
5. **Renames files and directories** in dependency order
6. **Records the operation** in history for undo support
7. **Optionally commits** to git if requested

## Examples

### Basic Apply

```bash
# Apply the default plan at .renamify/plan.json
renamify apply

# Explicitly apply the latest/default plan
renamify apply latest
```

### Apply by Plan ID

```bash
# Apply a specific plan from history
renamify apply abc123def456

# Apply from a file path
renamify apply ./my-rename-plan.json

# Apply from a custom location
renamify apply ./backups/old-plan.json
```

### Apply with Git Commit

```bash
# Apply changes and create a git commit
renamify apply --commit

# Apply specific plan with commit
renamify apply abc123def456 --commit
```

### Force Apply (Dangerous)

```bash
# Apply even if conflicts are detected
renamify apply --force-with-conflicts
```

## Atomic Operations

By default, `apply` uses atomic operations:

### What "Atomic" Means

- **All or nothing**: Either all changes succeed or none are applied
- **Temporary files**: Changes are written to temporary files first
- **Atomic rename**: Files are moved into place atomically
- **Rollback on failure**: If any step fails, all changes are reverted

### Benefits

- **No partial states**: Your codebase is never left in a half-modified state
- **Safe interruption**: You can safely Ctrl+C during application
- **Consistency**: All files are updated simultaneously

### Example Atomic Process

```bash
$ renamify apply

üìã Loading plan: .renamify/plan.json
üîç Validating 23 file modifications, 5 renames...
üíæ Creating backups...
‚úèÔ∏è  Applying content changes...
üìÅ Renaming files and directories...
‚úÖ Applied successfully! Operation ID: def456-20241201-150322

Backups stored in: .renamify/backups/def456-20241201-150322/
```

## Conflict Detection

Before applying, Renamify checks for various conflicts:

### File Modification Conflicts

```
‚ùå Conflict: File 'src/utils.js' has been modified since plan was created
   Plan checksum: abc123...
   Current checksum: def456...

Resolve by:
1. Recreating the plan: renamify plan old new
2. Or force apply: renamify apply --force-with-conflicts
```

### File Rename Conflicts

```
‚ùå Conflict: Multiple files would be renamed to 'components/Utils.js':
  - components/old_utils.js
  - components/oldUtils.js

Resolve by recreating plan with --exclude patterns.
```

### Missing Files

```
‚ùå Conflict: File 'src/missing.js' in plan no longer exists

The plan may be outdated. Consider recreating it.
```

## Git Integration

### Automatic Commits

```bash
renamify apply --commit
```

Creates a commit message like:

```
Renamify: getUserName ‚Üí fetchUserProfile

Applied renaming operation def456-20241201-150322:
- Modified 23 files
- Renamed 5 files
- Renamed 2 directories

Operation can be undone with: renamify undo def456-20241201-150322
```

### Pre-commit Requirements

If using `--commit`, ensure:

- Git working directory is clean (or you're okay with a mixed commit)
- You have appropriate git configuration (user.name, user.email)

## Backup System

Every apply operation creates comprehensive backups:

### Backup Structure

```
.renamify/backups/def456-20241201-150322/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ auth.js                 # Original file content
‚îÇ   ‚îî‚îÄ‚îÄ utils.js
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ UserProfile.tsx
‚îú‚îÄ‚îÄ checksums.json              # File integrity checksums
‚îî‚îÄ‚îÄ operation-info.json         # Operation metadata
```

### Backup Contents

- **Original file contents**: Exact copies before modification
- **Checksums**: SHA-256 hashes for integrity verification
- **Operation metadata**: Plan details, timestamps, file paths
- **Rename records**: Original ‚Üí new path mappings

## Error Handling

### Partial Application Failures

If any step fails during application:

```bash
‚ùå Error applying changes to 'src/readonly.js': Permission denied

Rolling back all changes...
‚úÖ All changes have been rolled back successfully.

To fix:
1. Check file permissions: ls -la src/readonly.js
2. Make writable: chmod +w src/readonly.js
3. Retry: renamify apply
```

### Recovery Steps

1. **Check file permissions** - Ensure you can write to all files
2. **Free disk space** - Ensure adequate space for operations
3. **Close editors** - Some editors may lock files
4. **Retry application** - Most errors are temporary

### Force Application

Use `--force-with-conflicts` only when you understand the risks:

```bash
# This bypasses safety checks - use carefully!
renamify apply --force-with-conflicts
```

## After Application

### Verify Changes

```bash
# Check what was actually applied
renamify history --limit 1

# Test your code
npm test  # or cargo test, etc.
```

### Undo if Needed

```bash
# Undo the last operation
renamify undo def456-20241201-150322

# Or see all operations and pick one
renamify history
renamify undo <operation-id>
```

### Clean Up

The plan file remains after application for reference:

```bash
# Remove the plan file if done
rm .renamify/plan.json

# Or keep it for documentation
```

## Performance Considerations

### Large Applications

For very large renaming operations:

- **Disk space**: Ensure you have space for backups (roughly 2x the size of
  modified files)
- **Memory usage**: Large plans may require significant RAM
- **Time**: Atomic operations on thousands of files can take time

### Optimization Tips

- **Close unnecessary programs** to free system resources
- **Use SSD storage** for faster file operations
- **Ensure stable power** for long operations

## Exit Codes

- `0` - Applied successfully
- `1` - Conflicts detected (use `--force-with-conflicts` to override)
- `2` - Invalid plan file or arguments
- `3` - Internal error or system issue

## Integration with Other Commands

### Typical Workflow

```bash
# 1. Plan the changes
renamify plan old_name new_name --preview table

# 2. Review the plan
cat .renamify/plan.json | jq '.stats'

# 3. Apply the plan
renamify apply --commit

# 4. Verify and test
git log --oneline -1
npm test
```

### Alternative: Use rename

For simpler cases, consider using `renamify rename` which combines planning and
applying:

```bash
# This does plan + apply in one step with confirmation
renamify rename old_name new_name --preview table --commit
```
