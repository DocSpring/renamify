---
title: MCP Usage Examples
description: Real-world examples of using the Renamify MCP Server
---

import { Code, Steps, Card, CardGrid } from '@astrojs/starlight/components';

Learn how to use the Renamify MCP Server through practical, real-world
scenarios.

## Basic Renaming Examples

### Example 1: Rename a React Component

**Scenario:** Rename `UserProfile` component to `CustomerProfile` across your
React application.

**AI Agent Conversation:**

```
User: "Rename the UserProfile component to CustomerProfile throughout the codebase"

AI: I'll help you rename UserProfile to CustomerProfile. Let me create a renaming plan:

Tool: renamify_plan
Arguments: {
  "old": "UserProfile",
  "new": "CustomerProfile",
  "includes": ["src/**/*.tsx", "src/**/*.ts", "src/**/*.jsx", "src/**/*.js"],
  "excludes": ["node_modules/**", "dist/**"],
  "styles": ["pascal", "camel"],
  "preview": "summary"
}

Result:
Created plan: 7f3a2b5c9d1e8f4a

Summary:
  Files to modify: 8
  Total replacements: 23
  Variants found:
    UserProfile (12)
    userProfile (11)
  Files to rename: 2
    src/components/UserProfile.tsx → src/components/CustomerProfile.tsx
    src/components/UserProfile.test.tsx → src/components/CustomerProfile.test.tsx

The renaming will update 8 files with 23 replacements and rename 2 files.
Shall I apply these changes?

User: "Yes, apply the changes"

AI: Applying the renaming now:

Tool: renamify_apply

Result: Successfully applied 23 replacements across 8 files and renamed 2 files.

The UserProfile component has been successfully renamed to CustomerProfile throughout your codebase!
```

### Example 2: Update Database Schema Names

**Scenario:** Migrate database schema from `user_accounts` to
`customer_accounts`.

```
User: "Change all references from user_accounts table to customer_accounts"

AI: I'll help rename the database table references. Creating a plan:

Tool: renamify_plan
Arguments: {
  "old": "user_accounts",
  "new": "customer_accounts",
  "includes": [
    "migrations/**/*.sql",
    "src/models/**/*.js",
    "src/queries/**/*.ts"
  ],
  "styles": ["snake", "camel", "pascal"],
  "renameFiles": false,
  "preview": "summary"
}

Result:
Created plan: 2d8e5f1a3b7c9d4e

Summary:
  Files to modify: 15
  Total replacements: 67
  Variants found:
    user_accounts (42)
    userAccounts (18)
    UserAccounts (7)

Note: File renaming is disabled to preserve migration file names.

Would you like me to apply these database schema changes?
```

### Example 3: API Endpoint Renaming

**Scenario:** Update API endpoints from `/api/get-user` pattern to
`/api/fetch-customer`.

```
User: "Replace all get-user API endpoints with fetch-customer"

AI: I'll rename the API endpoints from get-user to fetch-customer:

Tool: renamify_plan
Arguments: {
  "old": "get-user",
  "new": "fetch-customer",
  "includes": [
    "src/api/**/*.js",
    "src/services/**/*.ts",
    "tests/**/*.test.js",
    "docs/**/*.md"
  ],
  "styles": ["kebab", "camel", "snake"],
  "preview": "summary"
}

Result:
Created plan: 9c4e8f2a6b1d3a7f

Summary:
  Files to modify: 12
  Total replacements: 38
  Variants found:
    get-user (15)
    getUser (18)
    get_user (5)
  Files to rename: 1
    src/api/routes/get-user.js → src/api/routes/fetch-customer.js
```

## Advanced Workflows

### Workflow 1: Safe Production Renaming

**Scenario:** Rename production code with maximum safety.

<Steps>

1. **Check current status**

   ```
   Tool: renamify_status
   Arguments: {}
   ```

2. **Create dry-run plan**

   ```
   Tool: renamify_plan
   Arguments: {
     "old": "legacyFunction",
     "new": "modernFunction",
     "includes": ["src/**/*.js"],
     "dryRun": true,
     "preview": "diff"
   }
   ```

3. **Review the diff output carefully**

4. **Create actual plan if satisfied**

   ```
   Tool: renamify_plan
   Arguments: {
     "old": "legacyFunction",
     "new": "modernFunction",
     "includes": ["src/**/*.js"],
     "dryRun": false
   }
   ```

5. **Apply with git commit**

   ```
   Tool: renamify_apply
   Arguments: {
     "commit": true
   }
   ```

6. **Verify the changes**
   ```
   Tool: renamify_history
   Arguments: {
     "limit": 1
   }
   ```

</Steps>

### Workflow 2: Incremental Migration

**Scenario:** Migrate a large codebase in stages.

```
User: "I need to rename Product to Item but only in the backend first"

AI: I'll help you rename Product to Item in the backend only. Let's do this incrementally:

Step 1 - Backend models and database:

Tool: renamify_plan
Arguments: {
  "old": "Product",
  "new": "Item",
  "includes": [
    "backend/models/**/*.js",
    "backend/migrations/**/*.sql"
  ],
  "preview": "summary"
}

Result: Created plan with 45 replacements in 8 files

Step 2 - Backend API routes:

Tool: renamify_plan
Arguments: {
  "old": "Product",
  "new": "Item",
  "includes": [
    "backend/routes/**/*.js",
    "backend/controllers/**/*.js"
  ],
  "preview": "summary"
}

Result: Created plan with 67 replacements in 12 files

Would you like me to apply the backend model changes first?
```

### Workflow 3: Test-Driven Renaming

**Scenario:** Ensure tests pass after renaming.

```
User: "Rename calculatePrice to computeCost and make sure tests still pass"

AI: I'll rename calculatePrice to computeCost and verify the tests. Here's my approach:

Tool: renamify_plan
Arguments: {
  "old": "calculatePrice",
  "new": "computeCost",
  "includes": ["src/**/*.js", "tests/**/*.test.js"],
  "preview": "summary"
}

Result:
Created plan: 5b2a7f9c1e4d8f3a
  Files to modify: 15 (including 5 test files)
  Total replacements: 42

Now applying the changes:

Tool: renamify_apply

Result: Successfully applied 42 replacements

Let me run the tests to verify everything works:

[AI would then run: npm test]

The renaming is complete and all tests are passing!
```

## Pattern-Specific Examples

### Python Class Migration

```
Tool: renamify_plan
Arguments: {
  "old": "DataProcessor",
  "new": "DataTransformer",
  "includes": ["**/*.py"],
  "excludes": ["venv/**", "__pycache__/**"],
  "styles": ["pascal", "snake"],
  "preview": "summary"
}
```

### Go Package Rename

```
Tool: renamify_plan
Arguments: {
  "old": "userservice",
  "new": "customerservice",
  "includes": ["**/*.go", "go.mod"],
  "styles": ["camel", "pascal", "snake"],
  "preview": "summary"
}
```

### TypeScript Interface Update

```
Tool: renamify_plan
Arguments: {
  "old": "IUserData",
  "new": "ICustomerData",
  "includes": ["src/**/*.ts", "src/**/*.tsx"],
  "excludes": ["**/*.d.ts"],
  "styles": ["pascal"],
  "preview": "summary"
}
```

### Configuration File Updates

```
Tool: renamify_plan
Arguments: {
  "old": "MAX_USERS",
  "new": "MAX_CUSTOMERS",
  "includes": [
    "**/*.env",
    "**/*.json",
    "**/*.yaml",
    "**/*.yml",
    "config/**/*"
  ],
  "styles": ["screaming", "snake"],
  "renameFiles": false
}
```

## Error Recovery Examples

### Handling Conflicts

```
User: "Apply the renaming plan"

AI: Let me apply the renaming:

Tool: renamify_apply
Arguments: {}

Result: Error: Conflicts detected in 2 files:
  - src/api/users.js: Content changed since plan creation
  - src/models/user.js: File deleted

The files have changed since the plan was created. Let me create a fresh plan:

Tool: renamify_plan
Arguments: {
  "old": "User",
  "new": "Customer",
  "includes": ["src/**/*.js"],
  "preview": "summary"
}

Result: Created new plan: 8f2a6b1d3a7c9e4f
  Files to modify: 10 (was 12 - 2 files no longer exist)

Shall I apply the updated plan?
```

### Rolling Back Changes

```
User: "The renaming broke something, please undo it"

AI: I'll immediately undo the last renaming:

Tool: renamify_history
Arguments: {
  "limit": 1
}

Result: Last operation: 3a7c9d4e8f2b6a1d [APPLIED]

Tool: renamify_undo
Arguments: {
  "id": "3a7c9d4e8f2b6a1d"
}

Result: Successfully undone renaming 3a7c9d4e8f2b6a1d
  ✓ Reverted 85 replacements in 20 files
  ✓ Restored 3 renamed files

The renaming has been completely rolled back. Your code is now in its previous state.
```

## Best Practices Examples

### 1. Scoped Renaming

Instead of renaming everything at once, scope your changes:

```
# Good: Specific scope
Tool: renamify_plan
Arguments: {
  "old": "oldName",
  "new": "newName",
  "includes": ["src/components/**/*.tsx"],
  "excludes": ["**/*.test.tsx"]
}

# Risky: Too broad
Tool: renamify_plan
Arguments: {
  "old": "data",
  "new": "information",
  "includes": ["**/*"]
}
```

### 2. Test Before Production

Always test on a subset first:

```
# Step 1: Test on a small directory
Tool: renamify_plan
Arguments: {
  "old": "Widget",
  "new": "Component",
  "includes": ["src/ui/sample/**/*"],
  "dryRun": true
}

# Step 2: If good, expand to full directory
Tool: renamify_plan
Arguments: {
  "old": "Widget",
  "new": "Component",
  "includes": ["src/ui/**/*"]
}
```

### 3. Preserve Special Files

Exclude files that shouldn't change:

```
Tool: renamify_plan
Arguments: {
  "old": "config",
  "new": "settings",
  "includes": ["**/*.js"],
  "excludes": [
    "package-lock.json",
    "yarn.lock",
    "**/vendor/**",
    "**/third-party/**"
  ]
}
```

## Language-Specific Examples

### JavaScript/TypeScript

```json
{
  "includes": ["**/*.{js,jsx,ts,tsx,mjs}"],
  "styles": ["camel", "pascal"]
}
```

### Python

```json
{
  "includes": ["**/*.py"],
  "excludes": ["venv/**", "*.pyc"],
  "styles": ["snake", "pascal"]
}
```

### Go

```json
{
  "includes": ["**/*.go", "go.mod"],
  "styles": ["camel", "pascal"]
}
```

### Rust

```json
{
  "includes": ["**/*.rs", "Cargo.toml"],
  "styles": ["snake", "pascal"]
}
```

### Java

```json
{
  "includes": ["**/*.java"],
  "styles": ["camel", "pascal"]
}
```

### Ruby

```json
{
  "includes": ["**/*.rb"],
  "excludes": ["vendor/**"],
  "styles": ["snake", "pascal"]
}
```

## Next Steps

- [**AI Agent Guide**](/renamify/mcp/ai-guide) - Best practices for AI-assisted
  renaming
- [**Tools Reference**](/renamify/mcp/tools) - Detailed documentation for each
  tool
